{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Note</p> <p>The documentation and the tool are still in progress. Expect things to change or to break.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>This project started as a way to facitilate the process of performing complex electronic parametric simulations. Some of the simulations requirements are so convoluted that most of the tools are unable to perform them. This tool tries to solve this issue by providing an interface where user generated values are injected into multiple templates that can be fed to any software or script.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>This project has been heavily influenced by Task and Github actions.</p>"},{"location":"starting/","title":"Getting started","text":""},{"location":"starting/#installation","title":"Installation","text":"<p>Monaco can be built by having cargo installed in the system and then running the following commands.</p> <pre><code>$ git clone https://github.com/servinagrero/monaco &amp;&amp; cd monaco\n$ cargo install\n</code></pre> <p>The static binary <code>monaco</code> will be generated in the directory.</p>"},{"location":"starting/#using-monaco","title":"Using monaco","text":"<p>Monaco is designed to work as a standalone tool that reads a configuration file and spawn the appropiate commands. Nonetheless, it is designed to work also as a rust library, so other users can extend the way jobs can be launched. Monaco directly has support for YAML, TOML and JSON formats.</p> <p>To see all available monaco options, invoke it with the <code>--help</code> argument</p> <pre><code>$ monaco --help\nExecute jobs from a config file\n\nUsage: monaco [OPTIONS] --config &lt;CONFIG&gt;\n\nOptions:\n  -c, --config &lt;CONFIG&gt;  Path to the config file\n  -j, --job &lt;JOB&gt;        Name of the job to execute\n      --dry              Run in dry mode (Don't execute steps, just print them)\n-h, --help             Print help\n-V, --version          Print version\n</code></pre> <p>To invoke monaco and launch the jobs, pass the path to the configuration file through the <code>-c</code> argument. <pre><code>$ monaco -c /path/to/config.{yml|yaml|json|toml}\n</code></pre></p> <p>If the configuration file contains multiple jobs, we can direcly launch one by using the <code>--job</code> argument and the name of the job. </p> <pre><code>$ monaco -c /path/to/config.yml -j Job1\n</code></pre> <p>The section usage will explain in details the inner workings of monaco and all configuration options available.</p>"},{"location":"usage/","title":"Usage","text":"<p>When reading a configuration, monaco will make some healthchecks. Among other things, monaco will check for the following requirements in every job:</p> <ul> <li>The job dependencies exist.</li> <li>Template paths are not malformed.</li> <li>The iterations file is readable and contains a list of iterations.</li> <li>The ranges on the iterations are not malformed.</li> </ul>"},{"location":"usage/#executing-commands","title":"Executing commands","text":"<p>Commands are defined as short strings that get executed like shell commands. On windows they are executed with <code>cmd</code> while on linux they are executed with <code>/bin/sh</code>. The commands will be executed in the order they are defined. Each command gets executed in a different process, so the different commands cannot communicate between them directly.</p> Basic config file<pre><code>jobs:\n- name: Hello\nsteps: - echo \"hello world\"\n- name: Another\nsteps:\n- echo \"Hello from another\"\n# Would result in the output\n# hello world\n# Hello from another\n</code></pre> <p>We can also executed other jobs instead of shell commands by provididing the job name as map. Moreover, we can temporarely update the props and environment of the job if the <code>props</code> and <code>env</code> keys are also supplied.</p> Job calling another job<pre><code>jobs:\n- name: First\nsteps: - job: Second\n- name: Second\nsteps:\n- echo \"Hello from Second\"\n# Would result in the output\n# Hello from Second\n</code></pre> <p>Note that when a job has executed all of its commands, it gets marked as completed and it won't be executed again, even after successive calls, as depicted here.</p> Job calling another job<pre><code>jobs:\n- name: First\nsteps: - job: Second\n- job: Second\n- name: Second\nsteps:\n- echo \"Hello from Second\"\n# Would result in the output\n# Hello from Second\n</code></pre> <p>Monaco offers a couple of tools to address the number of times a job is able to be executed. The number of times a job is allowed to executed is controlled through the iterations configuration. There is also the when functionality that allows us to determine whether a job should run or not even if there are iterations.</p>"},{"location":"usage/#iterations","title":"Iterations","text":"<p>So far we have seen that we can launch jobs and execute commands. The problem is that these commands get executed only once. Monaco allows performing iterations on every job. There are multiple ways to define iterations:</p> <ul> <li>An absolute path to a JSON file containing an array.</li> <li>A boolean value to indicate whether the job will be executed once or in an infinite loop.</li> <li>A range of numbers provided with the keys <code>from</code>, <code>to</code> and an optional step with the key <code>by</code>.</li> <li>A list of values directly in the configuration file.</li> </ul> <p>As long as the iterations are contained in a list, we are able to utilize not only numbers, but complex objects as iterations, as it will be shown.  When executing multiple iterations, the iteration index can be accesed through the <code>iter</code> template variable.</p>"},{"location":"usage/#infinite-loop","title":"Infinite loop","text":"Example of an infinite loop<pre><code>jobs:\n- name: Test\niters: true # If false, only once iteration. It is the default behaviour\nsteps:\n- echo \"Infinite loop\"\n# Would result in the output\n# Infinite loop\n# Infinite loop\n# ...\n</code></pre>"},{"location":"usage/#iteration-list","title":"Iteration list","text":"Example of an iteration list<pre><code>jobs:\n- name: Test\niters: [1, 3, 5, 42]\nsteps:\n- echo \"We are on iteration {{iter}}\"\n# Would result in the output\n# We are on iteration 1\n# We are on iteration 3\n# We are on iteration 5\n# We are on iteration 42\n</code></pre>"},{"location":"usage/#range-of-values","title":"Range of values","text":"Example of range iteration<pre><code>jobs:\nTest:\niters:\n# from: 0 If from is not specified it defaults to 0\nend: 5\n# by: 1 The step defaults to 1\nsteps:\n- echo \"We are on iteration {{iter}}\"\n# Would result in the output\n# We are on iteration 0\n# We are on iteration 1\n# We are on iteration 2\n# We are on iteration 3\n# We are on iteration 4\n</code></pre>"},{"location":"usage/#iterations-from-json-file","title":"Iterations from JSON file","text":"iterations.json<pre><code>[{\"letter\": \"A\", \"idx\": 1}, {\"letter\": \"B\", \"idx\": 2}]\n</code></pre> Example on iterations from JSON file<pre><code>jobs:\n- name: Test\niters: \"iterations.json\"\nsteps:\n- echo \"Letter {{iter.letter}} and index {{iter.idx}}\"\n# Would result in the output\n# Letter A and index 1\n# Letter B and index 2\n</code></pre>"},{"location":"usage/#variable-interpolation","title":"Variable interpolation","text":"<p>Monaco provides two mechanisms that allow variable interpolation.</p> <ul> <li>Through the shell environment.</li> <li>Through mustache templates.</li> </ul>"},{"location":"usage/#shell-environment","title":"Shell environment","text":"<pre><code>jobs:\n- name: Test\nenv:\nANSWER: 42\nsteps:\n- echo \"the answer is $ANSWER\"\n# Would result in the output\n# The answer is 42\n</code></pre> <p>The environment can be also updated on a global basis if the <code>env</code> key is defined in the top level of the configuration. Each job is then free to override the variable if they are defined in their own scope.</p> <pre><code>env:\nfoo: bar\njobs:\n- name: First\nsteps:\n- echo \"Here foo is $foo\"\n- name: Second\nenv:\nfoo: 42\nsteps:\n- echo \"but here is $foo\"\n# Would result in the output\n# Here foo is bar\n# but here is 42\n</code></pre> <p>In the case that we want to keep some variables secret, we can provide <code>dotenv: true</code>. In this case, monaco will read the file <code>.env</code> from the configuration directory and put them in the global environment. The <code>.env</code> file is a simple text file where each line has the format <code>KEY=VALUE</code>. If the option is enabled but the <code>.env</code> file is not readable, monaco will print a warning</p> Example of .env<pre><code>PASS=1234\n</code></pre> Reading dotenv<pre><code>dotenv: true\njobs:\n- name: Test\nsteps:\n- echo \"The password is $PASS\"\n# Would result in the output\n# The password is 1234\n</code></pre> <p>The properties can be defined globally for all jobs if the <code>props</code> key is moved to the global scope. However, each job can override them if they are defined in their own scope.</p> <pre><code>env:\nfoo: bar\njobs:\n- name: First\nsteps:\n- echo \"Here foo is $foo\"\n- name: Second\nenv:\nfoo: 42\nsteps:\n- echo \"but here is $foo\"\n# Would result in the output\n# Here foo is bar\n# but here is 42\n</code></pre>"},{"location":"usage/#templates","title":"Templates","text":""},{"location":"usage/#redirecting-output","title":"Redirecting output","text":"<p>The outpt of all steps in a job can be redirected easily through the <code>log</code> variable. There are three possible values:</p> <ul> <li>If true is provided, the output will be redirected to standard out. This is the default behaviour.</li> <li>If fals is provided, no output will be emitted.</li> <li>If a string is provided, it will be treated as a template pointing to the path where the output will be apended. This file is recalculated for every iteration.</li> </ul> <p>As with most options, the log output can be set on a global basis and each job can override the value.</p> Redirecting output<pre><code>log: false\njobs:\n- name: First\ndir: /tmp\nlog: \"{{dir}}/output.log\"\nsteps:\n- echo \"This will be in the file\"\n- name: Second\nsteps:\n- echo \"This won't be seen\"\n</code></pre> /tmp/output.log<pre><code>This will be in the file\n</code></pre>"},{"location":"usage/#job-dependencies","title":"Job dependencies","text":"<p>We can add dependencies to a job if we need to run job before, even if they are declared after. To do that, add the name of the job dependency to the <code>depends</code> list.</p> <pre><code>jobs:\nSecond:\nrequires: - echo \"This will be the first command\"\n- {job: First}\nsteps:\n-echo \"And at last, this job\"\nFirst:\nsteps:\n- echo \"This will be the second command\"\n# Would result in the output\n# This will be the first command\n# This will be the second command\n# And at last, this job\n</code></pre>"},{"location":"usage/#chaning-directory","title":"Chaning directory","text":"<p>The directory of execution can be changed on a job basis by providing the <code>dir</code> key. The current directory can be used with the shell variable or through the template variable <code>dir</code>. If no directory is provided, it defaults to the configuration directory. The configuration directory can also be accessed through the template variable <code>config_dir</code>.</p> Changing execution directory<pre><code>jobs:\n- name: Test\ndir: /tmp\nsteps:\n- echo \"We are in $PWD\"\n- echo \"The same as {{dir}}\"\n- echo \"The config is on {{config_dir}}\"\n# Would result in the output\n# We are in /tmp\n# The same as /tmp\n# The config is on /path/to/config_dir\n</code></pre>"},{"location":"usage/#errors-during-execution","title":"Errors during execution","text":"<p>During the execution of multiple steps of a job, something could go wrong. If one of the commands fail to execute, monaco will not execute the rest of the steps. To ignore errors, provide the <code>ignore_errors: true</code> on a job basis. </p> Errors during execution<pre><code>jobs:\n- name: Test\nsteps: - echo \"You will see this\"\n- false\n- echo \"But you won't see this\"\n# Would result in the output\n# You will see this\n</code></pre> Ignoring errors<pre><code>jobs:\n- name: Test\nignore_errors: true\nsteps: - echo \"You will see this\"\n- false\n- echo \"And this too\"\n# Would result in the output\n# You will see this\n# And this too\n</code></pre>"},{"location":"usage/#conditional-execution","title":"Conditional execution","text":"<p>By default every job will be executed once. Once its execution has finished (either with errors or without errors), it will be marked as completed. In the case where a job has some iterations, all iterations will be executed.</p> Job is executed once<pre><code>jobs:\n- name: Parent\niters: [1, 2, 3]\nsteps: - job: Child\n- name: Child\nsteps:\n- echo \"This is executed only once\"\n# Would result in the output\n# This is executed only once\n</code></pre> <p>However, we can provide the <code>when</code> parameter to a job to check when a job should run. This parameter accepts a list of shell commands that will be executed in order. If all of the commands exit without errors, the job will be run. Since this option has precedence over the completed marker, we can launch the same job as many times as needed.</p> <p>For example, in order to always launch a job, we can use the <code>true</code> command as follows:</p> Conditional execution<pre><code>jobs:\n- name: Parent\niters: [1, 2, 3]\nsteps: - job: Child\n- name: Child\nsteps:\n- echo \"over and over\"\nwhen:\n- true\n# Would result in the output\n# over and over\n# over and over\n# over and over\n</code></pre>"}]}